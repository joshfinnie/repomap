mod formatter;
mod languages;
mod parser;
mod walk;

use anyhow::Result;
use clap::Parser;
use std::path::PathBuf;

use formatter::RepoStats;
use languages::Language;

#[derive(Parser, Debug)]
#[command(author, version, about = "Generate a repository map for AI context")]
struct Args {
    #[arg(
        short,
        long,
        help = "Force a specific language parser (overrides auto-detection)"
    )]
    language: Option<Language>,

    #[arg(default_value = ".")]
    root: String,

    #[arg(short, long, default_missing_value = "repomap.md", num_args = 0..=1)]
    output: Option<PathBuf>,

    #[arg(short, long)]
    exclude: Vec<String>,

    #[arg(short, long)]
    depth: Option<usize>,

    #[arg(short, long)]
    summary: bool,

    #[arg(
        long,
        help = "Output to CLAUDE.md with smart update (append or replace)"
    )]
    claude: bool,
}

fn main() -> Result<()> {
    let args = Args::parse();
    let mut stats = RepoStats::new();

    // Files to always exclude (generated by repomap)
    const EXCLUDED_FILES: &[&str] = &["repomap.md", "CLAUDE.md"];

    // Also exclude the specific output path if provided
    let output_path = if args.claude {
        Some(
            args.output
                .clone()
                .unwrap_or_else(|| PathBuf::from("CLAUDE.md")),
        )
    } else {
        args.output.clone()
    };
    let output_canonical = output_path.as_ref().and_then(|p| p.canonicalize().ok());

    for result in walk::create_walker(&args.root, args.depth, &args.exclude) {
        let entry = result?;
        let path = entry.path();

        // Skip generated files (repomap.md, CLAUDE.md) and the output file
        if let Some(file_name) = path.file_name().and_then(|n| n.to_str())
            && EXCLUDED_FILES.contains(&file_name)
        {
            continue;
        }
        if let Some(ref out_path) = output_canonical
            && let Ok(canonical) = path.canonicalize()
            && canonical == *out_path
        {
            continue;
        }

        if path.is_file() && !walk::is_binary(path) {
            let target_lang = args.language.or_else(|| languages::infer_language(path));
            if let Some(lang) = target_lang
                && let Ok((file_map, sym_count, line_count)) =
                    formatter::process_file_with_stats(path, lang)
                && !file_map.is_empty()
            {
                stats.add_file(path, file_map, sym_count, line_count);
            }
        }
    }

    let final_output = formatter::assemble_final_map(&args.root, &stats, args.summary);
    let token_estimate = stats.estimate_tokens(&final_output);

    eprintln!("----------------------------------------");
    eprintln!("Processed {} files.", stats.file_count);
    eprintln!("Estimated Tokens: ~{}", token_estimate);
    eprintln!("----------------------------------------");

    if args.claude {
        // --claude flag: wrap and smart update CLAUDE.md (or custom path)
        let output_path = args.output.unwrap_or_else(|| PathBuf::from("CLAUDE.md"));
        let wrapped =
            formatter::wrap_for_claude_md(&final_output, stats.file_count, token_estimate);

        let final_content = if output_path.exists() {
            let existing = std::fs::read_to_string(&output_path)?;
            formatter::update_or_append_repomap(&existing, &wrapped)
        } else {
            wrapped
        };

        std::fs::write(&output_path, &final_content)?;
        eprintln!("Map successfully written to: {}", output_path.display());
    } else if let Some(output_path) = &args.output {
        // Plain -o flag: simple overwrite
        std::fs::write(output_path, &final_output)?;
        eprintln!("Map successfully written to: {}", output_path.display());
    } else {
        println!("{}", final_output);
    }

    Ok(())
}
